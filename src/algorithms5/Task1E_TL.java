package algorithms5;
/**
 *
 E. Прибыльный стартап
 Ограничение времени 	1 секунда
 Ограничение памяти 	256Mb
 Ввод 	стандартный ввод или input.txt
 Вывод 	стандартный вывод или output.txt
 k друзей организовали стартап по производству укулеле для кошек. На сегодняшний день прибыль составила n рублей.
 Вы, как главный бухгалтер компании, хотите в каждый из ближайших d дней приписывать по одной цифре
 в конец числа,
 выражающего прибыль. При этом в каждый из дней прибыль должна делиться на k.
 Формат ввода
 В единственной строке входных данных через пробел записаны три числа: n,k,d — изначальная прибыль,
 количество учредителей компании и количество дней, которое вы собираетесь следить за прибылью (1≤n,k≤109,1≤d≤105).
 НЕ гарантируется, что n делится на k.
 Формат вывода
 Выведите одно целое число x — прибыль компании через d дней. Первые цифры числа x должны совпадать с числом n.
 Все префиксы числа x, которые длиннее числа n на 1,2,…,d цифр, должны делиться на k. Если возможных ответов
 несколько, выведите любой из них. Если ответа не существует, выведите −1.
 Пример 1
 Ввод
 21 108 1
 Вывод
 216
 Пример 2
 Ввод
 5 12 4
 Вывод
 -1

 Примечания
 В первом тестовом примере всего один день нужно следить за прибылью. Можно дописать цифру 6 в конец числа 21 и
 получить прибыль, делящуюся на 108.
 Во втором тестовом примере мы в первый же день не можем получить прибыль, делящуюся на k, какая бы цифра не была
 дописана у числу n, поэтому ответа не существует.
 */

import java.math.BigInteger;
import java.util.Scanner;

public class Task1E_TL {
    public static void main(String[] args) {
        int n, d;
        long k;
        Scanner s = new Scanner(System.in);
        n = s.nextInt();
        k = s.nextLong();
        d = s.nextInt();

        BigInteger[] nn= new BigInteger[d + 1];
        nn [0] = BigInteger.valueOf(n);

        for (int i = 0; i < d; i++) {
            for (long j = 0; j < 10; j++) {
                if ((nn[i].multiply(BigInteger.valueOf(10)).add(BigInteger.valueOf(j))).
                        mod(BigInteger.valueOf(k)).compareTo(BigInteger.valueOf(0)) == 0){
                    nn[i+1] = (nn[i].multiply(BigInteger.valueOf(10)).add(BigInteger.valueOf(j)));
                    break;
                }else {
                    if (j == 9){
                        System.out.println("-1");
                        return;
                    }
                }
            }
        }
        System.out.println(nn[d]);
    }
}
